# LangBench — бенчмаркер языков программирования

**LangBench** — это утилита для сравнения производительности программ, написанных на разных языках программирования.
Она автоматически запускает тесты, измеряет время выполнения, потребление памяти и другую системную информацию, а затем выводит сводные результаты. Легко масштабируема и легко настраиваема.

# Установка

```bash
git clone https://github.com/t3vsq2da/langbench
cd langbench
```

Для установки всех необходимых зависимостей, включая зависимости языков программирования используйте:

для Arch

```bash
bash ./setups/arch.sh
```

для Debian и Ubuntu

```bash
bash ./setups/debian-ubuntu.sh
```

Для тестирования только некоторых языков программирования, [установите зависимости в ручную](#ручная-установка-зависимостей)

# Использование

## Подготовка

Данный скрипт, настроит систему так, чтобы замеры были более точные и менее случайные.

```bash
chmod +x ./prepare.sh
./prepare.sh
```

## Запуск тестов

```bash
chmod +x bench.mjs
./bench.mjs
```

## Запуска с опциями

### Выборочный запуск

Есть возможность запуска только опеределнных тестов и языков:

```bash
./bench.mjs -t fib monte -l pypy3 cpp-clang
```

### Быстрый режим

Если передать в команде `-m fast` - вы включите быстрый режим, при котором убраны некоторые из тестов и языков.

```bash
./bench.mjs -m fast -ac 3
```

### Подробный режим

Если передать `-m detailed` - вы включите детальный режим, в котором будет больше тестов и языков, по сравнению с нормальным режимом.

```bash
./bench.mjs -m detailed
```

### Доступные опции

| Короткий флаг | Расшифровка          | Возможные значения                | Описание                                                                                                                                                                                  |
| ------------- | -------------------- | --------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `-t`          | `tests`              | Список имён тестов (через пробел) | Указывает, какие тесты выполнять. Пример: `-t fib sort`                                                                                                                                   |
| `-l`          | `langs`              | Список языков (через пробел)      | Ограничивает запуск только указанными языками. Пример: `-l rust go elixir`                                                                                                                |
| `-ac`         | `attempts-count`     | Целое число ≥ 1                   | Количество повторных запусков каждого теста. Итоговый результат — лучшая (наименее ресурсоёмкая) попытка.                                                                                 |
| `-m`          | `mode`               | `normal`,`fast`,`detailed`        | При `fast` отключает дополнительный тесты(начинаются с `++`), при `detailed` включает дополнительные тесты(начинаются с `!!`)                                                             |
| `-mt`         | `max-threads`        | cpu log cores > Целое числа ≥ 1   | Задает кол-во потоков, для выполнения мультипоточных тестов                                                                                                                               |
| `-ls`         | `log-stage`          | `0`,`1`,`2`                       | Выводить ли информацию о текущем этапе выполнения. При значение `2` информация более подробная.                                                                                           |
| `-lc`         | `log-commands`       | `true` / `false`                  | Логировать все выполняемые системные команды.                                                                                                                                             |
| `-la`         | `log-attempts`       | `true` / `false`                  | Показывать подробности по каждой попытке измерения.                                                                                                                                       |
| `-li`         | `log-individual`     | `0`, `1`, `2`                     | Уровень детализации по отдельным тестам:<br>• `0` — только результат всех тестов<br>• `1` — результаты для каждого из тестов<br>• `2` — более подробная информация для каждого из тестов. |
| `-llo`        | `log-launch-options` | `true` / `false`                  | Выводит опции запуска и информацию о системе .                                                                                                                                            |
| `-srt`        | save-result-table    | true / false                      | Сохраняет результаты тестов в файл bench-result.txt в текущей директории. Содержимое файла полностью совпадает с табличным выводом в консоли.                                             |
| `-srj`        | save-result-json     | true / false                      | Сохраняет результаты тестов в файл bench-result.json в текущей директории. Файл содержит сырые данные в формате JSON, которые отличаются от вывода в консоль.                             |

# Конфигурирование

## Файл `langs.json` — настройка языков программирования

Каждый язык описывается отдельным ключом и может содержать следующие поля:

- **`folder`** _(обязательно)_ — путь к папке с исходными кодами программ на этом языке. Если не задан - исходный код программ будет искаться в папке с тем же именем что и язык.
- **`req`** — список необходимых утилит (например, `gcc`, `node`, `elixir`). Если чего-то не хватает, LangBench сообщит об этом перед запуском. Проверка происходит через команду `which`.
- **`build`** — команда для компиляции программы. В ней можно использовать:
  - `<src>` -> будет заменен на полный путь к исходному файлу.
  - `<out>` -> будет заменен на имя выходного исполняемого файла(совпадает с полем `<src>` в запускаемом тесте).
- **`run`** — команда для запуска программы. Может содержать:
  - `<app>` -> будет заменен на файл приложения(если есть `build` то `<app>` = `<out>`, иначе `<app>` = путь до исходного файла).
  - `<threads-count>` -> будет заменен на кол-во доступных для теста ядер(их несколько если тест имеет опцию `multiThreads`).
- **`ext`** — расширение исходных файлов (например, `"cpp"`, `"rs"`, `"exs"`).
- **`out-file`** — путь выходного файла относительно директории `tmp`, **используется только для измерения его размера**. Нужно, когда имя результата нельзя определить автоматически (например, у Elixir нет единого бинарника). Может содержать:
  - `<test-src>` -> будет заменен на поле `src` из теста (используется, например, для Java).

> Если указано поле `build`, но не указано `run`, то после компиляции программа будет запускаться **напрямую как исполняемый файл** (`./<out>`).  
> Если язык не требует компиляции (например, Python), достаточно указать только `run`.
> Если не задан `build` и не задан `run`, в качестве команды запуска будет использоваться `<lang-name> ./<app>`.
> Все команды выполняются вне оболочки, а значит `|` (pipe), `>>` (append) и прочие возможности оболочки не доступны.

## Файл `tests.json` — описание тестов

Каждый тест задаётся отдельным ключом и содержит:

- **`src`** — имя исходного файла **без расширения**. Это же имя используется для выходного файла языка. Если не задан - поиск будет файла с тем же именем(без рассширения) что и тест.
- **`asserts`** — правила проверки корректности вывода программы:
  - Ключи — это аргументы командной строки, с которыми запускается программа. Может содержать `<threads>` за место которого будет подставлено значение опции `-mt`
  - Значения — ожидаемый **точный** вывод (включая переносы строк).
  - Если значение равно `null`, то проверка вывода для этого запуска **пропускается**.
- **`multiThreads`** — если значение `true`, программы может выполняться в несколько потоков(через `taskset -c`), по умолчанию `false`.
- **`before`** - команда которая выполнится перед запуском теста. По завершению теста, процесс созданный этой командой завершается принудительно.

## Специальные префиксы имён

- Имена тестов или языков, начинающиеся с **`--`**, **игнорируются всегда**.
- Имена, начинающиеся с **`++`**, **игнорируются в быстром режиме**, но участвуют в обычном прогоне.
- Имена, начинающиеся с **`!!`**, учавствуют только **в детальном режиме**.

> Пример: тест **`++monte-carlo`** будет запущен только при обычном режиме, но пропущен в быстром режиме.

# Прочее

## Изолирование ядер

Вы можете изолировать ядра на которых будут происходить тесты(индексами:0 для однопоточных тестов, 0-`<mt>` для многопоточных), для этого добавьте в опции запуска ядра Linux `isolcpus`, например, если вы используете `-mt 4`, то можете установить `isolcpus=0-3`. Это существенно повысит скорость тестов, и их точность.
**Не забудьте убрать** настройки обратно после прогона.

## Ручная установка зависимостей

### Обязательные зависимости

- node
- GNU time
- taskset

Для тестов http-сервера:

- oha

Для prepare.sh

- cpupower

### Зависимости языков

Для каждого из языков программирования есть свои зависимости, при запуске будут выведены не достающие

Для работы haskell/server.hs необходимо выполнить:

```bash
cabal update
cabal install --lib network
```

## P.S.

Весь код программ которые тестируются были созданы через AI.

в результатах теста, поле `time` это сумма user time и sys time, которые по умолчанию, представляют собой время выполнения толькой этой программы, но на **всех ядрах** в сумме, из чего следует, что запуская тест с разным кол-вом потоков, `time` не будет меняться, но реальное время выполнения (elapsed time) - изменяется, но не подходит для бенчмарка т.к. сильно зависит от нагруженности ядра другими программами.
