# LangBench — кроссплатформенный бенчмаркер языков программирования

**LangBench** — это утилита для сравнения производительности программ, написанных на разных языках программирования.  
Она автоматически запускает тесты, измеряет время выполнения, потребление памяти и другую системную информацию, а затем выводит сводные результаты.

## Запуск

Сделайте скрипт исполняемым (если ещё не сделано):

```bash
chmod +x bench.mjs
```

Запустите бенчмарк:

```bash
./bench.mjs [опции]
```

## Доступные опции

| Короткий флаг | Расшифровка         | Возможные значения                     | Описание |
|---------------|--------------------|----------------------------------------|----------|
| `-t`          | `tests`          | Список имён тестов (через пробел)     | Указывает, какие тесты выполнять. Пример: `-t fib sort` |
| `-l`          | `langs`          | Список языков (через пробел)          | Ограничивает запуск только указанными языками. Пример: `-l rust go elixir` |
| `-ac`         | `attempts-count` | Целое число ≥ 1                        | Количество повторных запусков каждого теста. Итоговый результат — лучшая (наименее ресурсоёмкая) попытка. |
| `-fm`         | `fast-mode`      | `true` / `false`                                   | Отключает расширенные тесты (те, что начинаются с `++`). Ускоряет прогон за счёт менее детального анализа. |
| `-mt`         | `max-threads`    | cpu log cores > Целое числа ≥ 1        | Задает кол-во потоков, для выполнения мультипоточных тестов |
| `-ls`         | `log-stage`      | `true` / `false`                       | Выводить ли информацию о текущем этапе выполнения.  |
| `-lc`         | `log-commands`   | `true` / `false`                       | Логировать все выполняемые системные команды. |
| `-la`         | `log-attempts`   | `true` / `false`                       | Показывать подробности по каждой попытке измерения. |
| `-li`         | `log-individual` | `0`, `1`, `2`                          | Уровень детализации по отдельным тестам:<br>• `0` — только результат всех тестов<br>• `1` — результаты для каждого из тестов<br>• `2` — более подробная информация для каждого из тестов. |
| `-lh`         | `log-hardware`   | `true` / `false`                       | Вывести информацию об оборудовании и ОС .|
| `-srt` | save-result-table | true / false | Сохраняет результаты тестов в файл bench-result.txt в текущей директории. Содержимое файла полностью совпадает с табличным выводом в консоли. |
| `-srj` | save-result-json | true / false | Сохраняет результаты тестов в файл bench-result.json в текущей директории. Файл содержит сырые данные в формате JSON, которые отличаются от вывода в консоль. |

## Примеры использования

### Рекомендуется перед тестом запустить prepare.sh
```bash
./prepare.sh
```
Данный скрипт, настроит систему так, чтобы замеры были более точные и менее случайные

### Запустить только тест `fib` на C++(компилятор clang)  и Rust, 3 попытки, с логированием этапов:
```bash
./bench.mjs -t fib -l "cpp gcc" rust
```

### Быстрый прогон без дополнителых тестов и минимальным логированием:
```bash
./bench.mjs -fm -ls false -li 0 -lh false
```

### Файл `langs.json` — настройка языков программирования

Каждый язык описывается отдельным ключом и может содержать следующие поля:

- **`folder`** — путь к папке с исходными кодами программ на этом языке.  
- **`req`** *(необязательно)* — список необходимых утилит (например, `gcc`, `node`, `elixir`). Если чего-то не хватает, LangBench сообщит об этом перед запуском.  
- **`build`** *(необязательно)* — команда для компиляции программы. В ней можно использовать:  
  - `<src>` → будет заменён на полный путь к исходному файлу,  
  - `<out>` → будет заменён на имя выходного исполняемого файла.  
- **`run`** *(необязательно)* — команда для запуска программы. Может содержать `<src>` (полезно для интерпретируемых языков, например, Python или Elixir).  
- **`ext`** *(необязательно)* — расширение исходных файлов (например, `"cpp"`, `"rs"`, `"exs"`).  
- **`out`** *(необязательно)* — имя выходного файла, **используется только для измерения его размера**. Нужно, когда имя результата нельзя определить автоматически (например, у Elixir нет единого бинарника). Может содержать `<out>` за место которого подставится имя исходного кода(нужно для Java)

> Если указано поле `build`, но не указано `run`, то после компиляции программа будет запускаться **напрямую как исполняемый файл** (`./<out>`).  
> Если язык не требует компиляции (например, Python), достаточно указать только `run`.

### Файл `tests.json` — описание тестов

Каждый тест задаётся отдельным ключом и содержит:

- **`src`** — имя исходного файла **без расширения**. Это же имя используется для выходного файла (если применимо).  
- **`asserts`** *(необязательно)* — правила проверки корректности вывода программы:  
  - Ключи — это аргументы командной строки, с которыми запускается программа.  
  - Значения — ожидаемый **точный** вывод (включая переносы строк).  
  - Если значение равно `null`, то проверка вывода для этого запуска **пропускается**.
- **`multiThreads`** *(необязательно)* — если значение `true`, программы может выполняться в несколько потоков(через `taskset -c`)

## Специальные префиксы имён

- Имена тестов или языков, начинающиеся с **`--`**, **игнорируются всегда** (полезно для временного отключения).  
- Имена, начинающиеся с **`++`**, **игнорируются в быстром режиме** (`-fm`), но участвуют в полном прогоне.

> Пример: тест `++monte-carlo` будет запущен только при обычном режиме, но пропущен при использовании флага `-fm`.