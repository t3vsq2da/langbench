#!/usr/bin/env node
import { LBError, Cmd, Entries, show, isArray } from "./lbench/utils.mjs";
import msgs, { format } from "./lbench/msgs.mjs";
import LaunchOptions from "./lbench/launchOptions.mjs";
import fs from "node:fs";
import Test from "./lbench/test.mjs";
import Lang from "./lbench/lang.mjs";
import process from "process";
import { fromStr } from "./lbench/cmd.mjs";

let launchOptions;

async function main(langsCfg, testsCfg) {
  show("s", "init tests&langs");

  const langs = Object.entries(langsCfg).map(
    ([name, data]) => new Lang(name, data),
  );

  const tests = Object.entries(testsCfg).map(
    ([name, data]) => new Test(name, data),
  );

  show("s", "check langs src");
  tests.forEach(({ src }) => langs.forEach((lang) => lang.findSrc(src)));

  show("s", "run langs setup cmds");
  for (const l of langs) if (l.setup) await Cmd.exec(...fromStr(l.setup));

  fs.rmSync("tmp", { recursive: true, force: true });
  fs.mkdirSync("tmp");

  const benchEntries = [];
  let startBenchTime = Date.now();

  for (let i = 0; i < tests.length; ++i) {
    const test = tests[i];
    show("s", msgs.tests.current(i, tests.length, test.name));

    const lBenchEntries = await test.benchLangs(langs);

    Entries.showTest(lBenchEntries);
    benchEntries.push(...lBenchEntries);
  }

  Entries.outEntriesTotal(benchEntries);
  show("o", "");
  show(
    "s",
    "the benchmark was completed in " +
      format.time((Date.now() - startBenchTime) / 1000),
  );
}

const mainWrapper = async () => {
  try {
    launchOptions = new LaunchOptions(process.argv);
    if (launchOptions.abort) return 0;
    await launchOptions.init();

    launchOptions.v?.forEach((cat) => (show.categories[cat].enabled = true));
    jsonOut.add({
      launchOptions: show("o", txtOut.add(launchOptions.toString())),
    });

    Test.attempts = launchOptions.ac;
    Test.maxThreads = launchOptions.mt;

    Entries.setJsonOut(jsonOut);
    Entries.setTxtOut(txtOut);

    await main(launchOptions.langs, launchOptions.tests);
  } catch (err) {
    if (err instanceof LBError) {
      console.error("\nLANG BENCH ERROR!");
      console.error(err.message);
    } else console.error(err);
  } finally {
    txtOut.save();
    jsonOut.save();
    if (fs.existsSync("tmp"))
      fs.rmSync("tmp", { force: true, recursive: true });
  }
};

mainWrapper();

const txtOut = {
  text: "",
  add(t) {
    this.text += t;
    return t;
  },
  save() {
    fs.writeFileSync("bench-result.txt", this.text);
  },
};

const jsonOut = {
  obj: { entries: [] },
  set(fields) {
    for (let k in fields) this.obj[k] = fields[k];
    return fields;
  },
  add(fields) {
    for (let k in fields) {
      const o = this.obj;
      if (k in o)
        if (isArray(o[k])) o[k].push(...fields[k]);
        else o[k] = [o[k], fields[k]];
      else o[k] = fields[k];
    }
    return fields;
  },
  save() {
    fs.writeFileSync("bench-result.json", JSON.stringify(this.obj));
  },
};
